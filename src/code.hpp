#ifndef HAS_CODE_BUNDLE
#define HAS_CODE_BUNDLE
#include <string>

namespace code_bundle
{
	void foreach(void* context, void(*callback)(void*, const char*, const char*, unsigned))
	{
		if (!callback)
			return;

		const char* sc_addon_cmakelists_txt = "cmake_minimum_required(VERSION 3.10)\nproject({{BUILDER_OUTPUT}})\nif (NOT DEFINED CMAKE_RUNTIME_OUTPUT_DIRECTORY)\n    set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_SOURCE_DIR}/bin)\n    set(CMAKE_RUNTIME_OUTPUT_DIRECTORY_DEBUG ${CMAKE_SOURCE_DIR}/bin)\n    set(CMAKE_RUNTIME_OUTPUT_DIRECTORY_RELEASE ${CMAKE_SOURCE_DIR}/bin)\n    set(CMAKE_RUNTIME_OUTPUT_DIRECTORY_RELWITHDEBINFO ${CMAKE_SOURCE_DIR}/bin)\n    set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_SOURCE_DIR}/bin)\n    set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY_DEBUG ${CMAKE_SOURCE_DIR}/bin)\n    set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY_RELEASE ${CMAKE_SOURCE_DIR}/bin)\n    set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY_RELWITHDEBINFO ${CMAKE_SOURCE_DIR}/bin)\n    set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_SOURCE_DIR}/bin)\n    set(CMAKE_LIBRARY_OUTPUT_DIRECTORY_DEBUG ${CMAKE_SOURCE_DIR}/bin)\n    set(CMAKE_LIBRARY_OUTPUT_DIRECTORY_RELEASE ${CMAKE_SOURCE_DIR}/bin)\n    set(CMAKE_LIBRARY_OUTPUT_DIRECTORY_RELWITHDEBINFO ${CMAKE_SOURCE_DIR}/bin)\nendif()\nadd_library({{BUILDER_OUTPUT}} SHARED\n    ${CMAKE_CURRENT_SOURCE_DIR}/interface.hpp\n    ${CMAKE_CURRENT_SOURCE_DIR}/addon.cpp)\nset_target_properties({{BUILDER_OUTPUT}} PROPERTIES\n    OUTPUT_NAME \"{{BUILDER_OUTPUT}}\"\n    CXX_STANDARD {{BUILDER_STANDARD}}\n    CXX_STANDARD_REQUIRED ON\n    CXX_EXTENSIONS OFF)\ntarget_compile_definitions({{BUILDER_OUTPUT}} PUBLIC -DASX_ADDON)";
		callback(context, "addon/CMakeLists.txt", sc_addon_cmakelists_txt, 1348);

		const char* sc_addon_addon_as = "import from \"console\";\n\nvoid print_hello_world()\n{\n    console@ log = console::get();\n    log.write_line(\"Hello, World\");\n}";
		callback(context, "addon/addon.as", sc_addon_addon_as, 123);

		const char* sc_addon_addon_cpp = "#include <iostream>\n#include \"interface.hpp\"\n\nvoid print_hello_world()\n{\n    std::cout << \"Hello, world!\" << std::endl;\n}\n\nextern \"C\" { INTERFACE_EXPORT int addon_import(); }\nint addon_import()\n{\n    asx_import_interface();\n    asx_export_function(\"void print_hello_world()\", &print_hello_world);\n    return 0;\n}\n\nextern \"C\" { INTERFACE_EXPORT void addon_cleanup(); }\nvoid addon_cleanup() { }";
		callback(context, "addon/addon.cpp", sc_addon_addon_cpp, 392);

		const char* sc_addon_addon_json = "{\n    \"name\": \"{{BUILDER_OUTPUT}}\",\n    \"type\": \"{{BUILDER_MODE}}\",\n    \"runtime\": \"{{BUILDER_VERSION}}\",\n    \"version\": \"1.0.0\",\n    \"index\": {{BUILDER_INDEX}}\n}";
		callback(context, "addon/addon.json", sc_addon_addon_json, 162);

		std::string dc_addon_interface_hpp;
		dc_addon_interface_hpp.reserve(7462);
		dc_addon_interface_hpp += "#ifndef ASX_INTERFACE_HPP\n#define ASX_INTERFACE_HPP\n#ifdef _WIN32\n#include <windows.h>\n#define INTERFACE_OPEN() GetModuleHandle(nullptr)\n#define INTERFACE_LOAD(handle, name) (void*)GetProcAddress(handle, #name)\n#define INTERFACE_CLOSE(handle) (void)0\n#define INTERFACE_EXPORT __declspec(dllexport)\n#else\n#include <dlfcn.h>\n#define INTERFACE_OPEN() dlopen(nullptr, RTLD_LAZY)\n#define INTERFACE_LOAD(handle, name) dlsym(handle, #name)\n#define INTERFACE_CLOSE(handle) dlclose(handle);\n#define INTERFACE_EXPORT\n#endif\nnamespace\n{\n\tvoid(*asx_import_builtin)(const char* path) = nullptr;\n\tvoid(*asx_import_native)(const char* path) = nullptr;\n\tvoid(*asx_export_property)(const char* declaration, void* property_address) = nullptr;\n\tvoid(*asx_export_function_address)(const char* declaration, void(*function_address)()) = nullptr;\n\tvoid(*asx_export_namespace_begin)(const char* name) = nullptr;\n\tvoid(*asx_export_namespace_end)() = nullptr;\n\tvoid(*asx_export_enum)(const char* name) = nullptr;\n\tvoid(*asx_export_enum_value)(const char* name, const char* declaration, int value) = nullptr;\n\tvoid(*asx_export_class_address)(const char* name, size_t size, size_t flags) = nullptr;\n\tvoid(*asx_export_class_property_address)(const char* name, const char* declaration, int property_offset) = nullptr;\n\tvoid(*asx_export_class_constructor_address)(const char* name, const char* declaration, void(*constructor_function_address)(void*)) = nullptr;\n\tvoid(*asx_export_class_operator_address)(const char* name, const char* declaration, void(*operator_function_address)()) = nullptr;\n\tvoid(*asx_export_class_copy_operator_address)(const char* name, void(*copy_operator_function_address)()) = nullptr;\n\tvoid(*asx_export_class_destructor_address)(const char* name, void(*destructor_function_address)(void*)) = nullptr;\n\tvoid(*asx_export_class_method_address)(const char* name, const char* declaration, void(*method_function_address)()) = nullptr;\n}\n\ntemplate <typename t, typename r, typename... args>\nstatic auto asx_operator(r(t::*value)(args...))\n{\n    return value;\n}\ntemplate <typename t, typename r, typename... args>\nstatic auto asx_operator(r(t::*value)(args...) const)\n{\n    return value;\n}\ntemplate <typename t, typename... args>\nstatic void asx_constructor(void* memory, args... data)\n{\n\tnew(memory) t(data...);\n}\ntemplate <typename t>\nstatic void asx_destructor(void* memory)\n{\n\t((t*)memory)->~t();\n}\ntemplate <typename t>\nvoid asx_export_function(const char* declaration, t function)\n{\n\tvoid(*function_address)() = reinterpret_cast<void(*)()>(size_t(function));\n\tasx_export_function_address(declaration, function_address);\n}\ntemplate <typename t>\nvoid asx_export_class(const char* name)\n{\n\tasx_export_class_address(name, sizeof(t),\n\t\t(std::is_default_constructible<t>::value ? 1 << 0 : 0) |\n\t\t(std::is_destructible<t>::value ? 1 << 1 : 0) |\n\t\t(std::is_copy_assignable<t>::value ? 1 << 2 : 0) |\n\t\t(std::is_copy_constructible<t>::value ? 1 << 4 : 0));\n}\ntemplate <typename t, typename r>\nvoid asx_export_class_property(const char* name, const char* declaration, r t::* value)\n{\n\tasx_export_class_property_address(name, declaration, (int)reinterpret_cast<size_t>(&(((t*)0)->*value)));\n}\ntemplate <typename t, typename... args>\nvoid asx_export_class_constructor(const char* name)\n{\n\tvoid(*constructor_address)(void*) = reinterpret_cast<void(*)(void*)>(&asx_constructor<t, args...>);\n\tasx_export_class_constructor_address(name, \"void f()\", constructor_address);\n}\ntemplate <typename t, typename... args>\nvoid asx_export_class_constructor(const char* name, const char* declaration)\n{\n\tvoid(*constructor_address)(void*) = reinterpret_cast<void(*)(void*)>(&asx_constructor<t, args...>);\n\tasx_export_class_constructor_address(name, declaration, constructor_address);\n}\ntemplate <typename t, typename r, typename... args>\nvoid asx_export_class_operator(const char* name, const char* declaration, r(t::* value)(args...))\n{\n    void(*operator_address)() = reinterpret_cast<void(*)()>(value);\n    asx_export_class_operator_address(name, declaration, operator_address);\n}\ntemplate <typename t, typename r, typename... ar";
		dc_addon_interface_hpp += "gs>\nvoid asx_export_class_operator(const char* name, const char* declaration, r(t::* value)(args...) const)\n{\n    void(*operator_address)() = reinterpret_cast<void(*)()>(value);\n\tasx_export_class_operator_address(name, declaration, operator_address);\n}\ntemplate <typename t, typename r, typename... args>\nvoid asx_export_class_copy_operator(const char* name)\n{\n\tvoid(*operator_address)() = reinterpret_cast<void(*)()>(asx_operator<t, r, args...>(&t::operator =));\n\tasx_export_class_copy_operator_address(name, operator_address);\n}\ntemplate <typename t, typename... args>\nvoid asx_export_class_destructor(const char* name)\n{\n\tvoid(*destructor_address)(void*) = reinterpret_cast<void(*)(void*)>(&asx_destructor<t, args...>);\n\tasx_export_class_destructor_address(name, destructor_address);\n}\ntemplate <typename t, typename r, typename... args>\nvoid asx_export_class_method(const char* name, const char* declaration, r(t::* value)(args...))\n{\n\tvoid(*method_function_address)() = reinterpret_cast<void(*)()>(value);\n\tasx_export_class_method_address(name, declaration, method_function_address);\n}\ntemplate <typename t, typename r, typename... args>\nvoid asx_export_class_method(const char* name, const char* declaration, r(t::* value)(args...) const)\n{\n\tvoid(*method_function_address)() = reinterpret_cast<void(*)()>(value);\n\tasx_export_class_method_address(name, declaration, method_function_address);\n}\nvoid asx_import_interface()\n{\n    auto handle = INTERFACE_OPEN();\n    asx_import_builtin = (decltype(asx_import_builtin))INTERFACE_LOAD(handle, asx_import_builtin);\n    asx_import_native = (decltype(asx_import_native))INTERFACE_LOAD(handle, asx_import_native);\n    asx_export_property = (decltype(asx_export_property))INTERFACE_LOAD(handle, asx_export_property);\n    asx_export_function_address = (decltype(asx_export_function_address))INTERFACE_LOAD(handle, asx_export_function_address);\n    asx_export_namespace_begin = (decltype(asx_export_namespace_begin))INTERFACE_LOAD(handle, asx_export_namespace_begin);\n    asx_export_namespace_end = (decltype(asx_export_namespace_end))INTERFACE_LOAD(handle, asx_export_namespace_end);\n    asx_export_enum = (decltype(asx_export_enum))INTERFACE_LOAD(handle, asx_export_enum);\n    asx_export_enum_value = (decltype(asx_export_enum_value))INTERFACE_LOAD(handle, asx_export_enum_value);\n    asx_export_class_address = (decltype(asx_export_class_address))INTERFACE_LOAD(handle, asx_export_class_address);\n    asx_export_class_property_address = (decltype(asx_export_class_property_address))INTERFACE_LOAD(handle, asx_export_class_property_address);\n    asx_export_class_constructor_address = (decltype(asx_export_class_constructor_address))INTERFACE_LOAD(handle, asx_export_class_constructor_address);\n    asx_export_class_operator_address = (decltype(asx_export_class_operator_address))INTERFACE_LOAD(handle, asx_export_class_operator_address);\n    asx_export_class_copy_operator_address = (decltype(asx_export_class_copy_operator_address))INTERFACE_LOAD(handle, asx_export_class_copy_operator_address);\n    asx_export_class_destructor_address = (decltype(asx_export_class_destructor_address))INTERFACE_LOAD(handle, asx_export_class_destructor_address);\n    asx_export_class_method_address = (decltype(asx_export_class_method_address))INTERFACE_LOAD(handle, asx_export_class_method_address);\n\tINTERFACE_CLOSE(handle);\n}\n#endif\n";
		callback(context, "addon/interface.hpp", dc_addon_interface_hpp.c_str(), (unsigned int)dc_addon_interface_hpp.size());

		const char* sc_executable_cmakelists_txt = "cmake_minimum_required(VERSION 3.10)\nset(VI_DIRECTORY \"{{BUILDER_VENGEANCE_PATH}}\" CACHE STRING \"-\")\n{{BUILDER_FEATURES}}\ninclude(${VI_DIRECTORY}/deps/vitex/deps/toolchain.cmake)\nproject({{BUILDER_OUTPUT}})\nset(CMAKE_DISABLE_IN_SOURCE_BUILD ON)\nset(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_SOURCE_DIR}/bin)\nset(CMAKE_RUNTIME_OUTPUT_DIRECTORY_DEBUG ${CMAKE_SOURCE_DIR}/bin)\nset(CMAKE_RUNTIME_OUTPUT_DIRECTORY_RELEASE ${CMAKE_SOURCE_DIR}/bin)\nset(CMAKE_RUNTIME_OUTPUT_DIRECTORY_RELWITHDEBINFO ${CMAKE_SOURCE_DIR}/bin)\nset(BUFFER_DATA \"#ifndef HAS_PROGRAM_BYTECODE\\n#define HAS_PROGRAM_BYTECODE\\n#include <string>\\n\\nnamespace program_bytecode\\n{\\n\\tvoid foreach(void* context, void(*callback)(void*, const char*, unsigned))\\n\\t{\\n\\t\\tif (!callback)\\n\\t\\t\\treturn;\\n\")\nset(BUFFER_OUT \"${CMAKE_SOURCE_DIR}/program\")\nset(FILENAME \"program_bytecode\")\nfile(READ \"${CMAKE_SOURCE_DIR}/program.b64\" FILEDATA)\nif (NOT FILEDATA STREQUAL \"\")\n    string(LENGTH \"${FILEDATA}\" FILESIZE)\n    if (FILESIZE GREATER 4096)\n        set(FILEOFFSET 0)\n        string(APPEND BUFFER_DATA \"\\n\\t\\tstd::string dc_${FILENAME};\\n\\t\\tdc_${FILENAME}.reserve(${FILESIZE});\")\n        while (FILEOFFSET LESS FILESIZE)\n            math(EXPR CHUNKSIZE \"${FILESIZE}-${FILEOFFSET}\")\n            if (CHUNKSIZE GREATER 4096)\n                set(CHUNKSIZE 4096)\n                string(SUBSTRING \"${FILEDATA}\" \"${FILEOFFSET}\" \"${CHUNKSIZE}\" CHUNKDATA)\n            else()\n                string(SUBSTRING \"${FILEDATA}\" \"${FILEOFFSET}\" \"-1\" CHUNKDATA)\n            endif()\n            string(APPEND BUFFER_DATA \"\\n\\t\\tdc_${FILENAME} += \\\"${CHUNKDATA}\\\";\")\n            math(EXPR FILEOFFSET \"${FILEOFFSET}+${CHUNKSIZE}\")\n        endwhile()\n        string(APPEND BUFFER_DATA \"\\n\\t\\tcallback(context, dc_${FILENAME}.c_str(), (unsigned int)dc_${FILENAME}.size());\\n\")\n    else()\n        string(APPEND BUFFER_DATA \"\\n\\t\\tconst char* sc_${FILENAME} = \\\"${FILEDATA}\\\";\\n\\t\\tcallback(context, sc_${FILENAME}, ${FILESIZE});\\n\")\n    endif()    \nendif()\nstring(APPEND BUFFER_DATA \"\\t}\\n}\\n#endif\")\nfile(WRITE ${BUFFER_OUT}.hpp \"${BUFFER_DATA}\")\t\nlist(APPEND SOURCE \"${BUFFER_OUT}.hpp\")\nadd_executable({{BUILDER_OUTPUT}}\n    ${CMAKE_CURRENT_SOURCE_DIR}/runtime.hpp\n    ${CMAKE_CURRENT_SOURCE_DIR}/program.hpp\n    ${CMAKE_CURRENT_SOURCE_DIR}/program.cpp)\nset_target_properties({{BUILDER_OUTPUT}} PROPERTIES\n    OUTPUT_NAME \"{{BUILDER_OUTPUT}}\"\n    CXX_STANDARD ${VI_CXX}\n    CXX_STANDARD_REQUIRED ON\n    CXX_EXTENSIONS OFF\n    VERSION ${PROJECT_VERSION}\n    SOVERSION ${PROJECT_VERSION})\nif (MSVC AND {{BUILDER_APPLICATION}})\n    set(CMAKE_EXE_LINKER_FLAGS \"/ENTRY:mainCRTStartup /SUBSYSTEM:WINDOWS\")\nendif()\nadd_subdirectory(${VI_DIRECTORY} vitex)\nlink_directories(${VI_DIRECTORY})\ntarget_include_directories({{BUILDER_OUTPUT}} PRIVATE ${VI_DIRECTORY})\ntarget_link_libraries({{BUILDER_OUTPUT}} PRIVATE vitex)";
		callback(context, "executable/CMakeLists.txt", sc_executable_cmakelists_txt, 2846);

		std::string dc_executable_program_cpp;
		dc_executable_program_cpp.reserve(5191);
		dc_executable_program_cpp += "#include \"program.hpp\"\n#include \"runtime.hpp\"\n#include <vengeance/vengeance.h>\n#include <vengeance/bindings.h>\n#include <vengeance/layer.h>\n#include <signal.h>\n\nusing namespace vitex::layer;\nusing namespace asx;\n\nevent_loop* loop = nullptr;\nvirtual_machine* vm = nullptr;\ncompiler* unit = nullptr;\nimmediate_context* context = nullptr;\nstd::mutex mutex;\nint exit_code = 0;\n\nvoid exit_program(int sigv)\n{\n\tif (sigv != SIGINT && sigv != SIGTERM)\n\t\treturn;\n\n\tumutex<std::mutex> unique(mutex);\n\t{\n\t\tif (runtime::try_context_exit(environment_config::get(), sigv))\n\t\t{\n\t\t\tloop->wakeup();\n\t\t\tgoto graceful_shutdown;\n\t\t}\n\n\t\tauto* app = application::get();\n\t\tif (app != nullptr && app->get_state() == application_state::active)\n\t\t{\n\t\t\tapp->stop();\n\t\t\tloop->wakeup();\n\t\t\tgoto graceful_shutdown;\n\t\t}\n\n\t\tif (schedule::is_available())\n\t\t{\n\t\t\tschedule::get()->stop();\n\t\t\tloop->wakeup();\n\t\t\tgoto graceful_shutdown;\n\t\t}\n\n\t\treturn std::exit((int)exit_status::kill);\n\t}\ngraceful_shutdown:\n\tsignal(sigv, &exit_program);\n}\nvoid setup_program(environment_config& env)\n{\n\tos::directory::set_working(env.path.c_str());\n\tsignal(SIGINT, &exit_program);\n\tsignal(SIGTERM, &exit_program);\n#ifdef VI_UNIX\n\tsignal(SIGPIPE, SIG_IGN);\n\tsignal(SIGCHLD, SIG_IGN);\n#endif\n}\nbool load_program(environment_config& env)\n{\n#ifdef HAS_PROGRAM_BYTECODE\n\tprogram_bytecode::foreach(&env, [](void* context, const char* buffer, unsigned size)\n\t{\n\t\tenvironment_config* env = (environment_config*)context;\n\t\tenv->program = codec::base64_decode(std::string_view(buffer, (size_t)size));\n\t});\n\treturn true;\n#else\n\treturn false;\n#endif\n}\nint main(int argc, char* argv[])\n{\n\tenvironment_config env;\n\tenv.path = *os::directory::get_module();\n\tenv.library = argc > 0 ? argv[0] : \"runtime\";\n\tenv.auto_schedule = {{BUILDER_ENV_AUTO_SCHEDULE}};\n\tenv.auto_console = {{BUILDER_ENV_AUTO_CONSOLE}};\n\tenv.auto_stop = {{BUILDER_ENV_AUTO_STOP}};\n\tif (!load_program(env))\n\t\treturn 0;\n\n\tvector<string> args;\n\targs.reserve((size_t)argc);\n\tfor (int i = 0; i < argc; i++)\n\t\targs.push_back(argv[i]);\n\n\tsystem_config config;\n\tconfig.permissions = { {{BUILDER_CONFIG_PERMISSIONS}} };\n\tconfig.libraries = { {{BUILDER_CONFIG_LIBRARIES}} };\n\tconfig.functions = { {{BUILDER_CONFIG_FUNCTIONS}} };\n\tconfig.system_addons = { {{BUILDER_CONFIG_ADDONS}} };\n\tconfig.tags = {{BUILDER_CONFIG_TAGS}};\n\tconfig.ts_imports = {{BUILDER_CONFIG_TS_IMPORTS}};\n\tconfig.essentials_only = {{BUILDER_CONFIG_ESSENTIALS_ONLY}};\n\tconfig.save_source_code = {{BUILDER_CONFIG_SAVE_SOURCE_CODE}};\n\tconfig.full_stack_tracing = {{BUILDER_CONFIG_FULL_STACK_TRACING}};\n\tsetup_program(env);\n\n\tsize_t modules = vitex::use_networking | vitex::use_cryptography | vitex::use_providers | vitex::use_locale;\n\tif (!config.essentials_only)\n\t\tmodules |= vitex::use_platform | vitex::use_audio | vitex::use_graphics;\n\n\tvitex::heavy_runtime scope(modules);\n\t{\n\t\tvm = new virtual_machine();\n\t\tbindings::heavy_registry().bind_addons(vm);\n\t\tunit = vm->create_compiler();\n\t\tcontext = vm->request_context();\n\n\t\tvector<std::pair<uint32_t, size_t>> settings = { {{BUILDER_CONFIG_SETTINGS}} };\n\t\tfor (auto& item : settings)\n\t\t\tvm->set_property((features)item.first, item.second);\n\n\t\tunit = vm->create_compiler();\n\t\texit_code = runtime::configure_context(config, env, vm, unit) ? (int)exit_status::OK : (int)exit_status::compiler_error;\n\t\tif (exit_code != (int)exit_status::OK)\n\t\t\tgoto finish_program;\n\n\t\truntime::configure_system(config);\n\t\tif (!unit->prepare(env.library))\n\t\t{\n\t\t\tVI_ERR(\"cannot prepare <%s> module scope\", env.library);\n\t\t\texit_code = (int)exit_status::prepare_error;\n\t\t\tgoto finish_program;\n\t\t}\n\n\t\tbyte_code_info info;\n\t\tinfo.data.insert(info.data.begin(), env.program.begin(), env.program.end());\n\t\tif (!unit->load_byte_code(&info).get())\n\t\t{\n\t\t\tVI_ERR(\"cannot load <%s> module bytecode\", env.library);\n\t\t\texit_code = (int)exit_status::loading_error;\n\t\t\tgoto finish_program;\n\t\t}\n\n\t\tprogram_entrypoint entrypoint;\n\t\tfunction main = runtime::get_entrypoint(env, entrypoint, unit);\n\t\tif (!main.is_valid())\n\t\t{\n\t\t\texit_code = (int)exit_status::entrypoint_error;\n\t\t\tgoto finish_program;\n\t\t}\n\n\t\tint exit_code =";
		dc_executable_program_cpp += " 0;\n\t\tauto type = vm->get_type_info_by_decl(\"array<string>@\");\n\t\tbindings::array* args_array = type.is_valid() ? bindings::array::compose<string>(type.get_type_info(), args) : nullptr;\n\t\tvm->set_exception_callback(&runtime::context_thrown);\n\n\t\tmain.add_ref();\n\t\tloop = new event_loop();\n\t\tloop->listen(context);\n\t\tloop->enqueue(function_delegate(main, context), [&main, args_array](immediate_context* context)\n\t\t{\n\t\t\truntime::startup_environment(environment_config::get());\n\t\t\tif (main.get_args_count() > 0)\n\t\t\t\tcontext->set_arg_object(0, args_array);\n\t\t}, [&exit_code, &type, &main, args_array](immediate_context* context)\n\t\t{\n\t\t\texit_code = main.get_return_type_id() == (int)type_id::void_t ? 0 : (int)context->get_return_dword();\n\t\t\tif (args_array != nullptr)\n\t\t\t\tcontext->get_vm()->release_object(args_array, type);\n\t\t\truntime::shutdown_environment(environment_config::get());\n\t\t\tloop->wakeup();\n\t\t});\n\n\t\truntime::await_context(mutex, loop, vm, context);\n\t}\nfinish_program:\n\tmemory::release(context);\n\tmemory::release(unit);\n\tmemory::release(vm);\n\tmemory::release(loop);\n\treturn exit_code;\n}";
		callback(context, "executable/program.cpp", dc_executable_program_cpp.c_str(), (unsigned int)dc_executable_program_cpp.size());

		std::string dc_executable_runtime_hpp;
		dc_executable_runtime_hpp.reserve(8114);
		dc_executable_runtime_hpp += "#ifndef RUNTIME_H\n#define RUNTIME_H\n#include <vengeance/bindings.h>\n#include <vengeance/vengeance.h>\n\nusing namespace vitex::core;\nusing namespace vitex::compute;\nusing namespace vitex::scripting;\n\nnamespace asx\n{\n\tenum class exit_status\n\t{\n\t\tnext = 0x00fffff - 1,\n\t\tok = 0,\n\t\truntime_error,\n\t\tprepare_error,\n\t\tloading_error,\n\t\tsaving_error,\n\t\tcompiler_error,\n\t\tentrypoint_error,\n\t\tinput_error,\n\t\tinvalid_command,\n\t\tinvalid_declaration,\n\t\tcommand_error,\n\t\tkill\n\t};\n\n\tstruct program_entrypoint\n\t{\n\t\tconst char* returns_with_args = \"int main(array<string>@)\";\n\t\tconst char* returns = \"int main()\";\n\t\tconst char* simple = \"void main()\";\n\t};\n\n\tstruct environment_config\n\t{\n\t\tinline_args commandline;\n\t\tunordered_set<string> addons;\n\t\tfunction_delegate at_exit;\n\t\tfile_entry file;\n\t\tstring name;\n\t\tstring path;\n\t\tstring program;\n\t\tstring registry;\n\t\tstring mode;\n\t\tstring output;\n\t\tstring addon;\n\t\tcompiler* this_compiler;\n\t\tconst char* library;\n\t\tint32_t auto_schedule;\n\t\tbool auto_console;\n\t\tbool auto_stop;\n\t\tbool inlined;\n\n\t\tenvironment_config() : this_compiler(nullptr), library(\"__anonymous__\"), auto_schedule(-1), auto_console(false), auto_stop(false), inlined(true)\n\t\t{\n\t\t}\n\t\tvoid parse(int args_count, char** args_data, const unordered_set<string>& flags = { })\n\t\t{\n\t\t\tcommandline = os::process::parse_args(args_count, args_data, (size_t)args_format::key_value | (size_t)args_format::flag_value | (size_t)args_format::stop_if_no_match, flags);\n\t\t}\n\t\tstatic environment_config& get(environment_config* other = nullptr)\n\t\t{\n\t\t\tstatic environment_config* base = other;\n\t\t\tVI_ASSERT(base != nullptr, \"env was not set\");\n\t\t\treturn *base;\n\t\t}\n\t};\n\n\tstruct system_config\n\t{\n\t\tunordered_map<string, std::pair<string, string>> functions;\n\t\tunordered_map<access_option, bool> permissions;\n\t\tvector<std::pair<string, bool>> libraries;\n\t\tvector<std::pair<string, int32_t>> settings;\n\t\tvector<string> system_addons;\n\t\tbool ts_imports = true;\n\t\tbool tags = true;\n\t\tbool debug = false;\n\t\tbool interactive = false;\n\t\tbool essentials_only = true;\n\t\tbool load_byte_code = false;\n\t\tbool save_byte_code = false;\n\t\tbool save_source_code = false;\n\t\tbool full_stack_tracing = true;\n\t\tbool dependencies = false;\n\t\tbool install = false;\n\t\tsize_t installed = 0;\n\t};\n\n\tclass runtime\n\t{\n\tpublic:\n\t\tstatic void startup_environment(environment_config& env)\n\t\t{\n\t\t\tif (env.auto_schedule >= 0)\n\t\t\t\tschedule::get()->start(env.auto_schedule > 0 ? schedule::desc((size_t)env.auto_schedule) : schedule::desc());\n\n\t\t\tif (env.auto_console)\n\t\t\t\tconsole::get()->attach();\n\t\t}\n\t\tstatic void shutdown_environment(environment_config& env)\n\t\t{\n\t\t\tif (env.auto_stop)\n\t\t\t\tschedule::get()->stop();\n\t\t}\n\t\tstatic void configure_system(system_config& config)\n\t\t{\n\t\t\tfor (auto& option : config.permissions)\n\t\t\t\tos::control::set(option.first, option.second);\n\t\t}\n\t\tstatic bool configure_context(system_config& config, environment_config& env, virtual_machine* vm, compiler* this_compiler)\n\t\t{\n\t\t\tvm->set_ts_imports(config.ts_imports);\n\t\t\tvm->set_module_directory(os::path::get_directory(env.path.c_str()));\n\t\t\tvm->set_preserve_source_code(config.save_source_code);\n\t\t\tvm->set_full_stack_tracing(config.full_stack_tracing);\n\n\t\t\tfor (auto& name : config.system_addons)\n\t\t\t{\n\t\t\t\tif (!vm->import_system_addon(name))\n\t\t\t\t{\n\t\t\t\t\tVI_ERR(\"%s import error: not found\", name.c_str());\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (auto& path : config.libraries)\n\t\t\t{\n\t\t\t\tif (!vm->import_clibrary(path.first, path.second))\n\t\t\t\t{\n\t\t\t\t\tVI_ERR(\"%s import error: %s not found\", path.second ? \"addon\" : \"clibrary\", path.first.c_str());\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (auto& data : config.functions)\n\t\t\t{\n\t\t\t\tif (!vm->import_cfunction({ data.first }, data.second.first, data.second.second))\n\t\t\t\t{\n\t\t\t\t\tVI_ERR(\"%s import error: %s not found\", data.second.first.c_str(), data.first.c_str());\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tauto* macro = this_compiler->get_processor();\n\t\t\tmacro->add_default_definitions();\n\n\t\t\tenv.this_compiler = this_compiler;\n\t\t\tbindings::tags::bind_syntax(vm, config.tags, &runtime::process_tags);\n\t\t\tenvironment_config::get(&env);\n\n\t\t\tvm->";
		dc_executable_runtime_hpp += "import_system_addon(\"ctypes\");\n\t\t\tvm->begin_namespace(\"this_process\");\n\t\t\tvm->set_function_def(\"void exit_event(int)\");\n\t\t\tvm->set_function(\"void before_exit(exit_event@)\", &runtime::apply_context_exit);\n\t\t\tvm->set_function(\"uptr@ get_compiler()\", &runtime::get_compiler);\n\t\t\tvm->end_namespace();\n\t\t\treturn true;\n\t\t}\n\t\tstatic bool try_context_exit(environment_config& env, int value)\n\t\t{\n\t\t\tif (!env.at_exit.is_valid())\n\t\t\t\treturn false;\n\n\t\t\tauto status = env.at_exit([value](immediate_context* context)\n\t\t\t{\n\t\t\t\tcontext->set_arg32(0, value);\n\t\t\t}).get();\n\t\t\tenv.at_exit.release();\n\t\t\tvirtual_machine::cleanup_this_thread();\n\t\t\treturn !!status;\n\t\t}\n\t\tstatic void apply_context_exit(asIScriptFunction* callback)\n\t\t{\n\t\t\tauto& env = environment_config::get();\n\t\t\tuptr<immediate_context> context = callback ? env.this_compiler->get_vm()->request_context() : nullptr;\n\t\t\tenv.at_exit = function_delegate(callback, *context);\n\t\t}\n\t\tstatic void await_context(std::mutex& mutex, event_loop* loop, virtual_machine* vm, immediate_context* context)\n\t\t{\n\t\t\tevent_loop::set(loop);\n\t\t\twhile (loop->poll_extended(context, 1000))\n\t\t\t{\n\t\t\t\tvm->perform_periodic_garbage_collection(60000);\n\t\t\t\tloop->dequeue(vm);\n\t\t\t}\n\n\t\t\tumutex<std::mutex> unique(mutex);\n\t\t\tif (schedule::has_instance())\n\t\t\t{\n\t\t\t\tauto* queue = schedule::get();\n\t\t\t\twhile (!queue->can_enqueue() && queue->has_any_tasks())\n\t\t\t\t\tqueue->dispatch();\n\t\t\t\tschedule::cleanup_instance();\n\t\t\t}\n\n\t\t\tevent_loop::set(nullptr);\n\t\t\tcontext->reset();\n\t\t\tvm->perform_full_garbage_collection();\n\t\t\tapply_context_exit(nullptr);\n\t\t}\n\t\tstatic void context_thrown(immediate_context* context)\n\t\t{\n\t\t\tif (context->will_exception_be_caught())\n\t\t\t\treturn;\n\n\t\t\tauto exception = bindings::exception::pointer();\n\t\t\texception.load_exception_data(context->get_exception_string());\n\t\t\texception.context = context;\n\n\t\t\tauto& type = exception.get_type();\n\t\t\tauto& text = exception.get_text();\n\t\t\tVI_PANIC(false, \"%s - %s\", type.empty() ? \"unknown_error\" : type.c_str(), text.empty() ? \"no description available\" : text.c_str());\n\t\t}\n\t\tstatic function get_entrypoint(environment_config& env, program_entrypoint& entrypoint, compiler* unit, bool silent = false)\n\t\t{\n\t\t\tfunction main_returns_with_args = unit->get_module().get_function_by_decl(entrypoint.returns_with_args);\n\t\t\tfunction main_returns = unit->get_module().get_function_by_decl(entrypoint.returns);\n\t\t\tfunction main_simple = unit->get_module().get_function_by_decl(entrypoint.simple);\n\t\t\tif (main_returns_with_args.is_valid() || main_returns.is_valid() || main_simple.is_valid())\n\t\t\t\treturn main_returns_with_args.is_valid() ? main_returns_with_args : (main_returns.is_valid() ? main_returns : main_simple);\n\n\t\t\tif (!silent)\n\t\t\t\tVI_ERR(\"%s module error: function \\\"%s\\\", \\\"%s\\\" or \\\"%s\\\" must be present\", env.library, entrypoint.returns_with_args, entrypoint.returns, entrypoint.simple);\n\t\t\treturn function(nullptr);\n\t\t}\n\t\tstatic compiler* get_compiler()\n\t\t{\n\t\t\treturn environment_config::get().this_compiler;\n\t\t}\n\n\tprivate:\n\t\tstatic void process_tags(virtual_machine* vm, bindings::tags::tag_info&& info)\n\t\t{\n\t\t\tauto& env = environment_config::get();\n\t\t\tfor (auto& tag : info)\n\t\t\t{\n\t\t\t\tif (tag.name != \"main\")\n\t\t\t\t\tcontinue;\n\n\t\t\t\tfor (auto& directive : tag.directives)\n\t\t\t\t{\n\t\t\t\t\tif (directive.name == \"#schedule::main\")\n\t\t\t\t\t{\n\t\t\t\t\t\tauto threads = directive.args.find(\"threads\");\n\t\t\t\t\t\tif (threads != directive.args.end())\n\t\t\t\t\t\t\tenv.auto_schedule = from_string<uint8_t>(threads->second).or_else(0);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tenv.auto_schedule = 0;\n\n\t\t\t\t\t\tauto stop = directive.args.find(\"stop\");\n\t\t\t\t\t\tif (stop != directive.args.end())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstringify::to_lower(threads->second);\n\t\t\t\t\t\t\tauto value = from_string<uint8_t>(threads->second);\n\t\t\t\t\t\t\tif (!value)\n\t\t\t\t\t\t\t\tenv.auto_stop = (threads->second == \"on\" || threads->second == \"true\" || threads->second == \"yes\");\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tenv.auto_stop = *value > 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (directive.name == \"#console::main\")\n\t\t\t\t\t\tenv.auto_console = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n#endif\n";
		callback(context, "executable/runtime.hpp", dc_executable_runtime_hpp.c_str(), (unsigned int)dc_executable_runtime_hpp.size());

		const char* sc_executable_vcpkg_json = "{\n    \"name\": \"{{BUILDER_OUTPUT}}\",\n    \"description\": \"Program: {{BUILDER_OUTPUT}}\",\n    \"version\": \"1.0.0\",\n    \"builtin-baseline\": \"e038ef04796ee67814f36af7c235ae50bbdf4303\",\n    \"dependencies\": {{BUILDER_CONFIG_INSTALL}}\n}";
		callback(context, "executable/vcpkg.json", sc_executable_vcpkg_json, 226);
	}
}
#endif